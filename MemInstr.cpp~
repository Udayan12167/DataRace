#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <set>
#include <cmath>

#include "pin.H"
#include "portability.H"
using namespace std;

/*
 * Name of the output file
 */
KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "buffer.out", "output file");

/*
 * Thread specific data
 */
TLS_KEY tls_key;

ADDRINT STACK_PTR_ERROR = 1000;




/*
 * Record of memory references.  Rather than having two separate
 * buffers for reads and writes, we just use one struct that includes a
 * flag for type.
 */
class ThreadLocalData
{
public:
	ThreadLocalData(THREADID tid);

    set<ADDRINT> readSet;
    set<ADDRINT> writeSet;
    PIN_LOCK threadlock;
    int inscount;
};

ThreadLocalData::ThreadLocalData(THREADID tid)
{
	inscount = 0;
	PIN_InitLock(&threadlock);
}

ThreadLocalData* getTLS(THREADID tid)
{
	ThreadLocalData* tld = static_cast<ThreadLocalData*>(PIN_GetThreadData(tls_key,tid));
	return tld;
}


BOOL isMemoryGlobal(ADDRINT effectiveAddr, ADDRINT stackPtr)
{

	if ((stackPtr-effectiveAddr) > STACK_PTR_ERROR)
		return true;

	return false;
}


inline VOID  MemoryWriteInstrumentation(THREADID threadid,
		ADDRINT effectiveAddr,//efecctive addr = memory addr
		ADDRINT stackPtr,	//stackPtr is required for determining whether the addrees is global or not (ie in heap or bss or initiliazed vars)
		ADDRINT insPtr,
		UINT32 writeSize
		){
	ThreadLocalData *tld = getTLS(threadid);
	if(isMemoryGlobal(effectiveAddr, stackPtr)){
		tld->writeSet.insert(effectiveAddr);
	}
}

inline VOID  MemoryReadInstrumentation(THREADID threadid,
		ADDRINT effectiveAddr,//efecctive addr = memory addr
		ADDRINT stackPtr,	//stackPtr is required for determining whether the addrees is global or not (ie in heap or bss or initiliazed vars)
		ADDRINT insPtr,
		UINT32 writeSize
		){
	ThreadLocalData *tld = getTLS(threadid);
	if(isMemoryGlobal(effectiveAddr, stackPtr)){
		tld->readSet.insert(effectiveAddr);
	}
}
/**************************************************************************
 *
 *  Instrumentation routines
 *
 **************************************************************************/

/*
 * Insert code to write data to a thread-specific buffer for instructions
 * that access memory.
 */
VOID Trace(TRACE trace, VOID *v)
{
	THREADID tid = PIN_ThreadId();
	ThreadLocalData *tld = getTLS(tid);
	PIN_GetLock(&tld->threadlock, tid);
    for(BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl=BBL_Next(bbl))
    {
        for(INS ins = BBL_InsHead(bbl); INS_Valid(ins); ins=INS_Next(ins))
        {
        	tld->inscount++;
            UINT32 memoryOperands = INS_MemoryOperandCount(ins);

            for (UINT32 memOp = 0; memOp < memoryOperands; memOp++)
            {

                // Note that if the operand is both read and written we log it once
                // for each.
                if (INS_MemoryOperandIsRead(ins, memOp))
                {
                    INS_InsertPredicatedCall(
							ins, IPOINT_BEFORE, (AFUNPTR)MemoryReadInstrumentation,
							IARG_THREAD_ID,
							IARG_MEMORYOP_EA, memOp,
							IARG_REG_VALUE, REG_STACK_PTR,//pass current stack ptr
							IARG_INST_PTR,
							IARG_MEMORYWRITE_SIZE,
							IARG_CALL_ORDER, CALL_ORDER_FIRST + 30,
							IARG_END);
                }

                if (INS_MemoryOperandIsWritten(ins, memOp))
                {
                    INS_InsertPredicatedCall(
							ins, IPOINT_BEFORE, (AFUNPTR)MemoryWriteInstrumentation,
							IARG_THREAD_ID,
							IARG_MEMORYOP_EA, memOp,
							IARG_REG_VALUE, REG_STACK_PTR, //pass current stack ptr
							IARG_INST_PTR,
							IARG_MEMORYWRITE_SIZE,
							IARG_CALL_ORDER, CALL_ORDER_FIRST + 30,
							IARG_END);
                }
            }
        }
    }
    PIN_ReleaseLock(&tld->threadlock);
}


/*
 * Note that opening a file in a callback is only supported on Linux systems.
 * See buffer-win.cpp for how to work around this issue on Windows.
 */
VOID ThreadStart(THREADID tid, CONTEXT *ctxt, INT32 flags, VOID *v)
{
    // There is a new MLOG for every thread.  Opens the output file.
    ThreadLocalData * tld = new ThreadLocalData(tid);

    // A thread will need to look up its MLOG, so save pointer in TLS
    PIN_SetThreadData(tls_key, tld, tid);

}


VOID ThreadFini(THREADID tid, const CONTEXT *ctxt, INT32 code, VOID *v)
{

	ThreadLocalData * tld = getTLS(tid);
	cout << tid << " contains:" << tld->inscount << endl;
	while (!tld->readSet.empty()) {
    	cout << ' ' << *tld->readSet.begin();
    	tld->readSet.erase(tld->readSet.begin());
  	}

  	while (!tld->writeSet.empty()) {
    	cout << ' ' << *tld->writeSet.begin();
    	tld->writeSet.erase(tld->writeSet.begin());
  	}
    PIN_SetThreadData(tls_key, 0, tid);
}


/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    cerr << "This tool demonstrates the basic use of the buffering API." << endl;
    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
    return -1;
}


/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
int main(int argc, char *argv[])
{
    // Initialize PIN library. Print help message if -h(elp) is specified
    // in the command line or the command line is invalid
    if( PIN_Init(argc,argv) )
    {
        return Usage();
    }
    
    // Initialize thread-specific data not handled by buffering api.
    tls_key = PIN_CreateThreadDataKey(0);
   
    // add an instrumentation function
    TRACE_AddInstrumentFunction(Trace, 0);

    // add callbacks
    PIN_AddThreadStartFunction(ThreadStart, 0);
    PIN_AddThreadFiniFunction(ThreadFini, 0);

    // Start the program, never returns
    PIN_StartProgram();
    
    return 0;
}